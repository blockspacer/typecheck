# -*- coding: utf-8 -*-
"""Typecheck Experimentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rr2fYXBnZVhbSm3So719zvuInQ60yHjv
"""

from typing import List, Dict

class FunctionType():
    arg_types: List[str]
    return_type: str

    def __init__(self):
        self.arg_types = []
        self.return_type = None

    def __str__(self):
        return "(" + (", ".join(self.arg_types) + ") -> " + ("void" if not self.return_type else self.return_type))

class ConstraintKind():
  # The two types must be bound to the same type. This is the only
  # truly symmetric constraint.
  Bind = 0
  # The two types must be bound to the same type, dropping
  # lvalueness when comparing a type variable to a type.
  Equal = 1
  # The first type is the type of a function parameter; the second
  # type is the type of a reference to that parameter from within the
  # function body. Specifically, the left type is an inout type iff the right
  # type is an lvalue type with the same object type. Otherwise, the two
  # types must be the same type.
  BindParam = 2
  # Binds the first type to the element type of the second type.
  BindToPointerType = 3
  # The first type is a subtype of the second type, i.e., a value
  # of the type of the first type can be used wherever a value of the
  # second type is expected.
  Subtype = 4
  # The first type is convertible to the second type.
  Conversion = 5
  # The first type can be bridged to the second type.
  BridgingConversion = 6
  # The first type is the element of an argument tuple that is
  # convertible to the second type (which represents the corresponding
  # parameter type).
  ArgumentConversion = 7
  # The first type is convertible to the second type, including inout.
  OperatorArgumentConversion = 8
  # The first type must conform to the second type (which is a
  # protocol type).
  ConformsTo = 9
  # The first type describes a literal that conforms to the second
  # type, which is one of the known expressible-by-literal protocols.
  LiteralConformsTo = 10
  # A checked cast from the first type to the second.
  CheckedCast = 11
  # The first type can act as the Self type of the second type (which
  # is a protocol).
  #
  # This constraint is slightly looser than a conforms-to constraint, because
  # an existential can be used as the Self of any protocol within the
  # existential, even if it doesn't conform to that protocol (e.g., due to
  # the use of associated types).
  SelfObjectOfProtocol = 12
  # Both types are function types. The first function type's
  # input is the value being passed to the function and its output
  # is a type variable that describes the output. The second
  # function type is expected to become a function type. Note, we
  # do not require the function type attributes to match.
  ApplicableFunction = 13
  # The first type is a function type whose input is the value passed
  # to the function and whose output is a type variable describing the output.
  # The second type is either a `@dynamicCallable` nominal type or the
  # function type of a `dynamicallyCall` method defined on a
  # `@dynamicCallable` nominal type.
  DynamicCallableApplicableFunction = 14
  # The first type is the type of the dynamicType member of the
  # second type.
  DynamicTypeOf = 15
  # Binds the left-hand type to a particular overload choice.
  BindOverload = 16
  # The first type has a member with the given name, and the
  # type of that member, when referenced as a value, is the second type.
  ValueMember = 17
  # The first type (which is implicit) has a member with the given
  # name, and the type of that member, when referenced as a value, is the
  # second type.
  UnresolvedValueMember = 18
  # The first type conforms to the protocol in which the member requirement
  # resides. Once the conformance is resolved, the value witness will be
  # determined, and the type of that witness, when referenced as a value,
  # will be bound to the second type.
  ValueWitness = 19
  # The first type can be defaulted to the second (which currently
  # cannot be dependent).  This is more like a type property than a
  # relational constraint.
  Defaultable = 20
  # A disjunction constraint that specifies that one or more of the
  # stored constraints must hold.
  Disjunction = 21
  # The first type is an optional type whose object type is the second
  # type, preserving lvalue-ness.
  OptionalObject = 22
  # The first type is the same function type as the second type, but
  # made @escaping.
  EscapableFunctionOf = 23
  # The first type is an opened type from the second type (which is
  # an existential).
  OpenedExistentialOf = 24
  # A relation between three types. The first is the key path type,
  # the second is the root type, and the third is the projected value type.
  # The second and third types can be lvalues depending on the kind of key
  # path.
  KeyPathApplication = 25
  # A relation between three types. The first is the key path type,
  # the second is its root type, and the third is the projected value type.
  # The key path type is chosen based on the selection of overloads for the
  # member references along the path.
  KeyPath = 26
  # The first type is a function type, the second is the function's
  # input type.
  FunctionInput = 27
  # The first type is a function type, the second is the function's
  # result type.
  FunctionResult = 28
  # The first type is a type that's a candidate to be the underlying type of
  # the second opaque archetype.
  OpaqueUnderlyingType = 29
  # The first type will be equal to the second type, but only when the
  # second type has been fully determined (and mapped down to a concrete
  # type). At that point, this constraint will be treated like an `Equal`
  # constraint.
  OneWayEqual = 30
  # The second type is the type of a function parameter, and the first type
  # is the type of a reference to that function parameter within the body.
  # Once the second type has been fully determined (and mapped down to a
  # concrete type), this constraint will be treated like a 'BindParam'
  # constraint.
  OneWayBindParam = 31
  # If there is no contextual info e.g. `_ = { 42 }` default first type
  # to a second type (inferred closure type). This is effectively a
  # `Defaultable` constraint which a couple of differences:
  #
  # - References inferred closure type and all of the outer parameters
  #   referenced by closure body.
  # - Handled specially by binding inference, specifically contributes
  #   to the bindings only if there are no contextual types available.
  DefaultClosureType = 32

class Constraint():
  kind: int
  type1: str
  type2: str
  protocol: str
  isResolved = False

def createEqualsConstraint(typeVar1, typeVar2):
  const = Constraint()
  const.kind = ConstraintKind.Equal
  const.type1 = typeVar1
  const.type2 = typeVar2
  return const

def createLiteralConformsToConstraint(typeVar, protocol):
  const = Constraint()
  const.kind = ConstraintKind.LiteralConformsTo
  const.type1 = typeVar
  const.protocol = protocol
  return const

def createFunctionConstraint(typeVar, argTypes, returnType):
  const = Constraint()
  const.kind = ConstraintKind.ApplicableFunction
  fType = FunctionType()
  fType.arg_types = argTypes
  fType.return_type = returnType
  const.type1 = typeVar
  const.type2 = fType
  return const

def createOverloadConstraint(typeVar, funcName):
  const = Constraint()
  const.kind = ConstraintKind.BindOverload
  const.type1 = typeVar
  const.protocol = funcName
  return const

def createConvertibleConstraint(typeVar, destTypeVar):
  const = Constraint()
  const.kind = ConstraintKind.Conversion
  const.type1 = typeVar
  const.type2 = destTypeVar
  return const

from typing import List, Dict

# object to manage available conversions
class Convertible():
  _conversions: Dict[str, List[str]]
  def __init__(self):
    self._conversions = {}

  def add_conversion(self, from_: str, to_: str):
    self._conversions.update({from_: self.get_conversions(from_) + [to_]})

  def get_conversions(self, from_: str):
    return self._conversions.get(from_, [])

class Protocol():
  name: str
  preferredTypes: []
  otherTypes: []

class ProtocolManager():
  _protocols: Dict[str, Protocol]

  def __init__(self):
    self._protocols = {}

  def add_protocol(self, pr: Protocol):
    self._protocols.update({pr.name: pr})

  def get_protocol(self, name: str):
    return self._protocols.get(name, None)

class FunctionDef():
  # name: str
  arg_types: List[str]
  return_type: str

  def __init__(self, _args, _return_type = "void"):
    # self.name = _name
    self.arg_types = _args
    self.return_type = _return_type

  def __str__(self):
    return "(" + (", ".join(self.arg_types) + ") -> " + ("void" if not self.return_type else self.return_type))

class FunctionsManager():
  _function_overloads = [str, List[FunctionDef]]
  def __init__(self):
    self._function_overloads = {}

  def add_overload(self, name: str, f: FunctionDef):
    self._function_overloads.update({name: self.get_overloads(name) + [f]})

  def get_overloads(self, name: str):
    return self._function_overloads.get(name, [])

class TypeManager():
  def __init__(self):
    self.protocols = ProtocolManager()
    self.conversions = Convertible()
    self.functions = FunctionsManager()

import copy

def get_cost(constraint: Constraint, typeVars, manager: TypeManager):
  # TODO: Mark reason and score
  if constraint.isResolved:
    if constraint.kind == ConstraintKind.LiteralConformsTo:
      defined_protocol = manager.protocols.get_protocol(constraint.protocol)
      constraint_type = typeVars[constraint.type1]
      if defined_protocol:
        if constraint_type in defined_protocol.preferredTypes:
          return 0
        elif constraint_type in defined_protocol.otherTypes:
          return 1
      else:
        raise RuntimeError("Unknown protocol in cost")
    elif constraint.kind == ConstraintKind.Equal:
      if (typeVars[constraint.type1] == typeVars[constraint.type2]):
          # They are equal
          return 0
      else:
          # No met
          return 10
    elif constraint.kind == ConstraintKind.ApplicableFunction:
      found_all_args = True
      for arg in constraint.type2.arg_types:
        if arg not in typeVars.keys():
          found_all_args = False
      found_all_args = found_all_args and constraint.type2.return_type in typeVars.keys() and typeVars.get(constraint.type2.return_type) != ""
      found_all_args = found_all_args and constraint.type1 in typeVars.keys() and typeVars.get(constraint.type1) != ""

      if found_all_args:
        return 0
      else:
        return 1000
    elif constraint.kind == ConstraintKind.BindOverload:
        func_var = constraint.type1
        if func_var in typeVars.keys():
          func_overload = typeVars.get(func_var)
          return 0
        else:
          return 1000
    elif constraint.kind == ConstraintKind.Conversion:
      t1 = typeVars.get(constraint.type1)
      t2 = typeVars.get(constraint.type2)
      if t2 in manager.conversions.get_conversions(t1):
        return 0
      else:
        return 1000
    else:
      raise RuntimeError("Unknown cost Constraint Type: " + str(constraint.kind))

  # Inccur cost of the unresolved cost
  return 1000

def cost_constraints(constraints, typeVars, manager: TypeManager):
  cost = 0
  for constraint in constraints:
    cost += get_cost(constraint, typeVars, manager)
  return cost

def resolveEqualConstraint(constraint, typeVars, manager: TypeManager):
    T1 = constraint.type1
    T2 = constraint.type2
    if typeVars.get(T1, "") == "" and typeVars.get(T2, "") == "":
      # Can't resolve yet
      yield (False, typeVars)
    elif typeVars.get(T1, "") == "":
      newVars = copy.deepcopy(typeVars)
      newVars.update({T2: typeVars.get(T1)})
      yield (True, newVars)
    elif typeVars.get(T2, "") == "":
      newVars = copy.deepcopy(typeVars)
      newVars.update({T1: typeVars.get(T2)})
      yield (True, newVars)
    else:
      # already been resolved
      yield (True, typeVars)

def resolveLiteralConformsToConstraint(constraint, typeVars, manager: TypeManager):
    T1 = constraint.type1
    defined_protocol = manager.protocols.get_protocol(constraint.protocol)
    if defined_protocol:
      for ty in defined_protocol.preferredTypes:
        newVars1 = copy.deepcopy(typeVars)
        newVars1.update({T1: ty})
        yield (True, newVars1)
      for ty in defined_protocol.otherTypes:
        newVars1 = copy.deepcopy(typeVars)
        newVars1.update({T1: ty})
        yield (True, newVars1)
    else:
      raise RuntimeError("Unknown protocol in constraints")

def resolveApplicableFunctionConstraint(constraint, typeVars, manager: TypeManager):
    did_break = False
    fResolvedType = FunctionType()
    newVars1 = copy.deepcopy(typeVars)

    # Wait to select an overload before we delve into the function
    current_overload = typeVars.get(constraint.type1)
    if not current_overload or len(current_overload.arg_types) != len(constraint.type2.arg_types):
        did_break = True
    else:
      for i in range(len(current_overload.arg_types)):
        # overload may not override existing constraint
        if constraint.type2.arg_types[i] in typeVars.keys():
          if current_overload.arg_types[i] != typeVars.get(constraint.type2.arg_types[i]):
            did_break = True
        fResolvedType.arg_types.append(current_overload.arg_types[i])
        newVars1.update({constraint.type2.arg_types[i]: current_overload.arg_types[i]})

      if current_overload.return_type:
        # overload may not override existing constraint
        if constraint.type2.return_type in typeVars.keys():
          if current_overload.return_type != typeVars.get(constraint.type2.return_type):
            did_break = True
        fResolvedType.return_type = current_overload.return_type
        newVars1.update({constraint.type2.return_type: current_overload.return_type})

    if not did_break:
      newVars1.update({constraint.type1: fResolvedType})
      # This is a function Type
      yield (True, newVars1)
    else:
      yield (False, typeVars)

def resolveBindOverloadConstraint(constraint, typeVars, manager: TypeManager):
    func_overloads: List[FunctionDef] = manager.functions.get_overloads(constraint.protocol)
    all_passed = True
    if len(func_overloads) > 0:
      # Get the vars, see if they match up
      # func_var = typeVars.get(constraint.protocol) # expect this to be a FunctionType
      did_find_overload = False
      valid_overload = True
      for overload in func_overloads:
        if valid_overload:
          did_find_overload = True
          # we found a good one!
          newVars1 = copy.deepcopy(typeVars)
          newVars1.update({constraint.type1: overload})
          yield (True, newVars1)
      if not did_find_overload:
        all_passed = False

    if constraint.type1 not in typeVars.keys():
      typeVars.update({constraint.type1: ""})
      # This is a function Type
      yield (False, typeVars)
    elif not all_passed:
      yield (False, typeVars)

def resolveConversionConstraint(constraint, typeVars, manager: TypeManager):
  if constraint.type1 in typeVars.keys():
    available_conversions = manager.conversions.get_conversions(typeVars.get(constraint.type1))
    if typeVars.get(constraint.type1) != "":
      # Try them all
      for conversion in available_conversions:
        newVars1 = copy.deepcopy(typeVars)
        newVars1.update({constraint.type2: typeVars.get(constraint.type1)})
        # This is a function Type
        yield (True, newVars1)
    else:
      yield (False, typeVars)
  else:
    yield (False, typeVars)
def resolveConstraint(constraint, typeVars, manager: TypeManager):
  if constraint.kind == ConstraintKind.Equal:
      yield from resolveEqualConstraint(constraint, typeVars, manager)
  elif constraint.kind == ConstraintKind.LiteralConformsTo:
      yield from resolveLiteralConformsToConstraint(constraint, typeVars, manager)
  elif constraint.kind == ConstraintKind.ApplicableFunction:
      yield from resolveApplicableFunctionConstraint(constraint, typeVars, manager)
  elif constraint.kind == ConstraintKind.BindOverload:
      yield from resolveBindOverloadConstraint(constraint, typeVars, manager)
  elif constraint.kind == ConstraintKind.Conversion:
      yield from resolveConversionConstraint(constraint, typeVars, manager)
  else:
    raise RuntimeError("Unknown Constraint Type: " + str(constraint.kind))

def tryResolve(constraints, typeVars, manager: TypeManager, last_failed  = None):
  # TODO: as an optimization, sort them based on simplest first (for least repetition)
  best_score = 1_000_000_000_000 # (infinity, for purpose of demonstration)
  currVars = typeVars
  if len(constraints) > 0:
    curr_constraint = constraints[0]
    for didUpdate, vars in resolveConstraint(curr_constraint, currVars, manager):
      if didUpdate:
        curr_constraint.isResolved = True
        # Pass down everything from i onwards
        new_cost, new_vars = tryResolve(constraints[1:], vars, manager, last_failed = None)
        computed_cost = cost_constraints(constraints, new_vars, manager)
        if (computed_cost < best_score):
          best_score = computed_cost
          currVars = new_vars
      else:
        # We didn't update this constraint
        # Move the current one to the end
        if len(constraints) > 1 and curr_constraint is not last_failed: # Prevent from going in circles
            new_cost, new_vars = tryResolve(constraints[1:] + [curr_constraint], vars, manager, last_failed = curr_constraint if last_failed is None else last_failed)
            computed_cost = cost_constraints(constraints, new_vars, manager)
            if (computed_cost < best_score):
              best_score = computed_cost
              currVars = new_vars
        else:
            return (cost_constraints(constraints, currVars, manager), currVars)
  return (best_score, currVars)

def solve(constraints, typeVars, manager: TypeManager):
  cost, final_vars = tryResolve(constraints, typeVars, manager)
  for constraint in constraints:
    if not constraint.isResolved:
      print("Failed to resolve constraint")
  print("-- Got Final Solution --")
  print(cost)
  # print solution
  out_str = "{"
  for k, v in final_vars.items():
    out_str += (str(k) + ": " + str(v) + "  ")
  out_str += "}"
  print(out_str)
  return final_vars

manager = TypeManager()
manager.conversions.add_conversion("int", "int")
manager.conversions.add_conversion("int", "float")
manager.conversions.add_conversion("int", "double")
manager.conversions.add_conversion("double", "double")
manager.conversions.add_conversion("float", "float")
manager.conversions.add_conversion("float", "double")

pr1 = Protocol()
pr1.name = "ExpressibleByInt"
pr1.preferredTypes = ["int"]
pr1.otherTypes = ["double", "float"]
manager.protocols.add_protocol(pr1)

pr2 = Protocol()
pr2.name = "ExpressibleByDouble"
pr2.preferredTypes = ["double"]
pr2.otherTypes = []
manager.protocols.add_protocol(pr2)

const1 = createLiteralConformsToConstraint("T1", "ExpressibleByInt")
const2 = createLiteralConformsToConstraint("T2", "ExpressibleByInt")
const3 = createEqualsConstraint("T1", "T2")

solve([const1, const2, const3], {}, manager)

const1 = createLiteralConformsToConstraint("T1", "ExpressibleByInt")
const2 = createLiteralConformsToConstraint("T2", "ExpressibleByDouble")
const3 = createEqualsConstraint("T1", "T2")

solve([const1, const2, const3], {}, manager)

manager2 = copy.deepcopy(manager)
manager2.functions.add_overload("foo", FunctionDef(["int", "int"], "int"))
manager2.functions.add_overload("foo", FunctionDef(["double", "double"], "double"))
#manager2.functions.add_overload("foo", FunctionDef(["int", "int"], "double"))
#manager2.functions.add_overload("foo", FunctionDef(["float", "float"], "double"))
manager2.functions.add_overload("foo", FunctionDef(["float", "float"], "float"))

"""
T1 conforms to ExpressibleByIntegerLiteral
T2 conforms to ExpressibleByIntegerLiteral
T0 is a function that takes (T1, T2) and returns T3
T0 is one of 28 implementations in the Swift standard library named infix +
T3 is convertible to T4
"""
const1 = createLiteralConformsToConstraint("T1", "ExpressibleByInt")
const2 = createLiteralConformsToConstraint("T2", "ExpressibleByDouble")
const3 = createFunctionConstraint("T0", ["T1", "T2"], "T3")
const4 = createOverloadConstraint("T0", "foo")
const5 = createConvertibleConstraint("T3", "T4")
solve([const1, const2, const3, const4, const5], {}, manager2)
del manager2


"""
T1 conforms to ExpressibleByIntegerLiteral
T3 conforms to ExpressibleByIntegerLiteral
T2 is a function that takes (T3) and returns T4
T2 is one of 6 implementations in the Swift standard library named prefix -
T0 is a function that takes (T1, T4) and returns T5
T0 is one of 28 implementations in the Swift standard library named infix +
T5 is convertible to Double
"""
manager3 = copy.deepcopy(manager)
manager3.functions.add_overload("foo", FunctionDef(["int"], "int"))
manager3.functions.add_overload("foo", FunctionDef(["double"], "double"))
manager3.functions.add_overload("foo", FunctionDef(["float"], "int"))
manager3.functions.add_overload("foo", FunctionDef(["float"], "double"))
manager3.functions.add_overload("foo", FunctionDef(["int"], "float"))
manager3.functions.add_overload("foo", FunctionDef(["int"], "double"))

manager3.functions.add_overload("bar", FunctionDef(["int", "int"], "int"))
manager3.functions.add_overload("bar", FunctionDef(["double", "double"], "double"))

solve([createLiteralConformsToConstraint("T1", "ExpressibleByInt"),
       createLiteralConformsToConstraint("T3", "ExpressibleByInt"),
       createFunctionConstraint("T2", ["T3"], "T4"),
       createOverloadConstraint("T2", "foo"),
       createFunctionConstraint("T0", ["T1", "T4"], "T5"),
       createOverloadConstraint("T0", "bar")], {"T5": "double"}, manager3)